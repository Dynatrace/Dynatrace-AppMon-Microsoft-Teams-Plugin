
 /**
  * This template file was generated by dynaTrace client.
  * The dynaTrace community portal can be found here: http://community.compuwareapm.com/
  * For information how to publish a plugin please visit http://community.compuwareapm.com/plugins/contribute/
  **/ 

package com.Dynatrace;

import com.dynatrace.diagnostics.pdk.*;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.Collection;
import java.util.logging.Logger;
import org.apache.commons.lang3.StringUtils;

public class MSTeams implements ActionV2 {

	private static final Logger log = Logger.getLogger(MSTeams.class.getName());


	/**
	 * Initializes the Plugin. This method is called in the following cases:
	 * <ul>
	 * <li>before <tt>execute</tt> is called the first time for this
	 * scheduled Plugin</li>
	 * <li>before the next <tt>execute</tt> if <tt>teardown</tt> was called
	 * after the last execution</li>
	 * </ul>
	 * 
	 * <p>
	 * If the returned status is <tt>null</tt> or the status code is a
	 * non-success code then {@link #teardown(ActionEnvironment)} will be called
	 * next.
	 * 
	 * <p>
	 * Resources like sockets or files can be opened in this method.
	 * Resources like sockets or files can be opened in this method.
	 * @param env
	 *            the configured <tt>ActionEnvironment</tt> for this Plugin
	 * @see #teardown(ActionEnvironment)
	 * @return a <tt>Status</tt> object that describes the result of the
	 *         method call
	 */
	@Override
	public Status setup(ActionEnvironment env) throws Exception {
		// TODO
		return new Status(Status.StatusCode.Success);
	}

	/**
	 * Executes the Action Plugin to process incidents.
	 * 
	 * <p>
	 * This method may be called at the scheduled intervals, but only if incidents
	 * occurred in the meantime. If the Plugin execution takes longer than the
	 * schedule interval, subsequent calls to
	 * {@link #execute(ActionEnvironment)} will be skipped until this method
	 * returns. After the execution duration exceeds the schedule timeout,
	 * {@link ActionEnvironment#isStopped()} will return <tt>true</tt>. In this
	 * case execution should be stopped as soon as possible. If the Plugin
	 * ignores {@link ActionEnvironment#isStopped()} or fails to stop execution in
	 * a reasonable timeframe, the execution thread will be stopped ungracefully
	 * which might lead to resource leaks!
	 * 
	 * @param env
	 *            a <tt>ActionEnvironment</tt> object that contains the Plugin
	 *            configuration and incidents
	 * @return a <tt>Status</tt> object that describes the result of the
	 *         method call
	 */
	@Override
	public Status execute(ActionEnvironment env) throws Exception {
        String systemProfileName = env.getSystemProfileName();
        //MAP ALL INCIDENTS A COLLECTION
		Collection<Incident> incidents = env.getIncidents();
		
		//FOR EACH INCIDENT
		for (Incident incident : incidents) {
			
			//LOG INCIDENT MESSAGE
			String incidentMessage = incident.getMessage();
			log.fine("Incident " + incidentMessage + " triggered.");
			
			//SET URL FROM USER INPUT FIELD
			URL url = env.getConfigUrl("url");
                        
                        //OPEN URL CONNECTION AND SET TIMEOUTS - USES CONNECTION METHOD 'POST'
			HttpURLConnection con = (HttpURLConnection) url.openConnection();
			con.setRequestMethod("POST");
			con.setConnectTimeout(5000);
			con.setReadTimeout(20000);
			
			//SET VARIABLES
			OutputStream out;
			InputStream in;
			int responseCode;
			String responseBody;
			String incidentUUID;
			String incidentRule;
			String startTime;
			String endTime;
			String incidentTime;
			String incidentStatus;
			String incidentSeverity;
            String incidentViolation = "";
            String incidentImage;
            String incidentColor = "";
            String sourceType = "";
            String sourceName = "";
            String sourceHostName = "";
                        //JSON CREATION
			//JSONObject jsonObj = new JSONObject();
                        
                        // Compose string chat_message => This message will be sent to the SlackChat channel

                        incidentRule = incident.getIncidentRule().getName();

                        incidentUUID = incident.getKey().getUUID() + "\n";
                        
                        startTime = incident.getStartTime().toString();
                        endTime = incident.getEndTime().toString();
                        
                        if (incident.isOpen()){
                             incidentStatus = "Started";
                             incidentColor = "ff0000";
                             incidentTime = "Start time: " + startTime;
			            }
                        else if (incident.isClosed()){
                            incidentStatus = "Ended";
                            incidentColor = "00ff00";
                     //       incidentTime = "Start time: " + startTime + "\\n";
                            incidentTime = "End time: " + endTime;
                        }
                        else {
							incidentStatus = "Unknown status";
                            incidentStatus = "Unknown status";
                            incidentTime = "Unknown time";
                        }
						incidentSeverity = getSeverityAsString(incident);

                        if (incidentStatus.equals("Started")) {
							incidentImage = "https://raw.githubusercontent.com/tutnes/Dynatrace-MSTeams-Integration-Plugin/master/images/incident-severe.png";
						}
						else {
							incidentImage = "https://raw.githubusercontent.com/tutnes/Dynatrace-MSTeams-Integration-Plugin/master/images/incident-ended.png";
						}

                        for (Violation violation : incident.getViolations()) {
                            incidentViolation = "Violated Measure: " + violation.getViolatedMeasure().getName() + " - Threshold: " + violation.getViolatedThreshold().getValue();
                            Measure violatedMeasure = violation.getViolatedMeasure();
                            Source source = violatedMeasure.getSource();
							MonitorSource monitorSource;
                            if (source.getSourceType() == SourceType.Monitor) {
                                sourceType = "Monitor";
                                sourceName = (monitorSource = (MonitorSource)source).getName();
                                String sMeasure = violatedMeasure.getName();
                                if(sMeasure.contains("@"))
                                {
                                    sourceHostName = StringUtils.substringAfter(sMeasure, "@");
                                    sourceHostName = StringUtils.substringBefore(sourceHostName,")");
                                 }
                            } else if (source.getSourceType() == SourceType.Agent) {
                                sourceType = "Agent";
                                sourceName = ((AgentSource) source).getName().toString();
                                sourceHostName = ((AgentSource) source).getHost().toString();
                            }
                            for (Violation.TriggerValue trigger : violation.getTriggerValues()) {
                                incidentViolation += "- Value: " + trigger.getValue().toString();
                            }
						}

			
            /*
             * Create JSON Object => Will be sent to SlackChat via HTTP POST
             */

				String jayson = "{\n" +
					"  \"summary\": \"Alert\",\n" +
					"  \"themeColor\": \"" + incidentColor + "\",\n" +
					"  \"title\": \" "+ incidentSeverity + " Incident: " + incidentRule + "\",\n" +
					"  \"sections\": [\n" +
					"    {\n" +
					"      \"activityTitle\": \"**" + incidentStatus + "**\",\n" +
					"      \"activitySubtitle\": \"" + incidentTime +"\",\n" +
					"      \"activityImage\": \"" + incidentImage + "\",\n" +
                    "      \"activityText\": \"" + incidentViolation + "\",\n" +
					"      \"facts\": [\n" +
					"        {\n" +
					"          \"name\": \""+ sourceType +"\",\n" +
					"          \"value\": \""+ sourceName +"\"\n" +
					"        },\n" +
					"        {\n" +
					"          \"name\": \"Hosts:\",\n" +
					"          \"value\": \"" + sourceHostName+"\"\n" +
					"        },\n" +
					"        {\n" +
					"          \"name\": \"System profile:\",\n" +
					"          \"value\": \""+ systemProfileName +"\"\n" +
					"        }\n" +
					"      ],\n" +
					"      \"text\": \"" + incidentMessage + "\"\n" +
					"    }\n" +
					"  ]\n" +
					"}";










            //log.info(jayson);



                        
                        
                        //JSON TO STRING
			//String jsonString = jsonObj.toJSONString();
			String jsonString = jayson;

			//LOG JSON STRING
			log.fine("JSON String is: " + jsonString);
			
			//JSON STRING TO BYTES
			byte[] payload = jsonString.getBytes();
			
			//SET CONNECTION OUTPUT
			con.setFixedLengthStreamingMode(payload.length);
                        con.setRequestProperty("Content-Type", "application/json; charset=UTF-8");
			con.setDoOutput(true);
			
			//LOG PROGRESS
			log.fine("Trying to get output stream...");
			
			//TRY TO GET OUTPUT STREAM
			try{
                            out = con.getOutputStream();
			}
			
			//CATCH EXCEPTION, LOG IT THEN SEND RESPONSE ERROR CODE
			catch (IOException e){
                            log.severe("Exception thrown whilst getting output stream...");
                            log.severe(e.toString());
                            con.disconnect();
                            return new Status (Status.StatusCode.ErrorInternalException);
			}
			
			//LOG PROGRESS
			log.fine("Trying to write to output stream");
			
			//TRY TO SEND PAYLOAD
			try{
                            out.write(payload);
                            out.close();
			}
			
			//CATCH EXCEPTION, LOG IT THEN SEND RESPONSE ERROR CODE
			catch (IOException e) {
                            log.severe("Exception thrown whilst writing to output stream...");
                            log.severe(e.toString());
                            con.disconnect();
                            return new Status (Status.StatusCode.ErrorInternalException);
			}
			
			//LOG PROGRESS
			log.fine("Trying to connect...");
                        
                        			
			//TRY TO GET RESPONSE CODE
			try{
                            responseCode = con.getResponseCode();
                            log.fine("Response Code : " + responseCode);
			}
			
			//CATCH EXCEPTION, LOG IT THEN SEND RESPONSE ERROR CODE
			catch (IOException e) {
                            log.severe("Exception thrown whilst writing to output stream...");
                            log.severe(e.toString());
                            con.disconnect();
                            return new Status (Status.StatusCode.ErrorInternalException);
			}

			//DISCONNECT
			finally{
				con.disconnect();
			}
                }
                
		return new Status(Status.StatusCode.Success);
	}

	/**
	 * Shuts the Plugin down and frees resources. This method is called in the
	 * following cases:
	 * <ul>
	 * <li>the <tt>setup</tt> method failed</li>
	 * <li>the Plugin configuration has changed</li>
	 * <li>the execution duration of the Plugin exceeded the schedule timeout</li>
	 * <li>the schedule associated with this Plugin was removed</li>
	 * </ul>
	 * <p>
	 * The Plugin methods <tt>setup</tt>, <tt>execute</tt> and
	 * <tt>teardown</tt> are called on different threads, but they are called
	 * sequentially. This means that the execution of these methods does not
	 * overlap, they are executed one after the other.
	 * 
	 * <p>
	 * Examples:
	 * <ul>
	 * <li><tt>setup</tt> (failed) -&gt; <tt>teardown</tt></li>
	 * <li><tt>execute</tt> starts, configuration changes, <tt>execute</tt>
	 * ends -&gt; <tt>teardown</tt><br>
	 * on next schedule interval: <tt>setup</tt> -&gt; <tt>execute</tt> ...</li>
	 * <li><tt>execute</tt> starts, execution duration timeout,
	 * <tt>execute</tt> stops -&gt; <tt>teardown</tt></li>
	 * <li><tt>execute</tt> starts, <tt>execute</tt> ends, schedule is
	 * removed -&gt; <tt>teardown</tt></li>
	 * </ul>
	 * Failed means that either an unhandled exception is thrown or the status
	 * returned by the method contains a non-success code.
	 * 
	 * <p>
	 * All by the Plugin allocated resources should be freed in this method.
	 * Examples are opened sockets or files.
	 * 
	 * @see #setup(ActionEnvironment)
	 */
	@Override
	public void teardown(ActionEnvironment env) throws Exception {
		// TODO
	}
    private String getSeverityAsString(Incident incident) {
        if (incident.getSeverity() != null) {
            switch (incident.getSeverity()) {
                case Error:
                    return "Critical";
                case Informational:
                    return "Information";
                case Warning:
                    return "Warning";
            }
        }
        return "";
    }
}
